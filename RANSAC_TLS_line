import numpy as np

def tls_line_from_points(P):
    # P: NÃ—2, returns (a,b,d) with ||[a,b]||=1 and ax+by+d=0
    c = P.mean(axis=0)
    U, S, Vt = np.linalg.svd(P - c)
    n = Vt[-1]               # normal direction
    n = n / np.linalg.norm(n)
    d = -n.dot(c)
    return n[0], n[1], d

def line_dist(P, a,b,d):
    return np.abs(a*P[:,0] + b*P[:,1] + d)

def circle_from_3(p1,p2,p3):
    A = np.array([
        [2*(p2[0]-p1[0]), 2*(p2[1]-p1[1])],
        [2*(p3[0]-p1[0]), 2*(p3[1]-p1[1])]
    ])
    b = np.array([
        p2[0]**2 - p1[0]**2 + p2[1]**2 - p1[1]**2,
        p3[0]**2 - p1[0]**2 + p3[1]**2 - p1[1]**2
    ])
    if np.linalg.det(A) == 0: return None
    cx, cy = np.linalg.solve(A, b)
    r = np.linalg.norm([cx-p1[0], cy-p1[1]])
    return cx, cy, r

def circle_radial_error(P, cx,cy,r):
    return np.abs(np.hypot(P[:,0]-cx, P[:,1]-cy) - r)

def ransac_line(P, thr=0.25, min_inliers=25, iters=500):
    best = (None, [])
    N = len(P)
    for _ in range(iters):
        idx = np.random.choice(N, 2, replace=False)
        a,b,d = tls_line_from_points(P[idx])
        err = line_dist(P, a,b,d)
        inl = np.where(err <= thr)[0]
        if len(inl) > len(best[1]):
            a2,b2,d2 = tls_line_from_points(P[inl])
            best = ((a2,b2,d2), inl.tolist())
            if len(inl) >= min_inliers:  # early accept
                pass
    return best

def ransac_circle(P, thr=0.35, min_inliers=25, iters=1000):
    best = ((0,0,0), [])
    N = len(P)
    for _ in range(iters):
        i,j,k = np.random.choice(N, 3, replace=False)
        mdl = circle_from_3(P[i], P[j], P[k])
        if mdl is None: continue
        cx,cy,r = mdl
        err = circle_radial_error(P, cx,cy,r)
        inl = np.where(err <= thr)[0]
        if len(inl) > len(best[1]):
            # refine by least squares on inliers
            rr = np.hypot(P[inl,0]-cx, P[inl,1]-cy).mean()
            best = ((cx,cy,rr), inl.tolist())
            if len(inl) >= min_inliers:
                pass
    return best

if __name__ == "__main__":
    # Generate the noisy set X (same as the PDF intent, simplified)
    np.random.seed(0)
    N = 100
    r = 10.0
    cx_gt, cy_gt = 2.0, 3.0
    t = np.random.uniform(0, 2*np.pi, N//2)
    n = (r/16.0)*np.random.randn(N//2)
    xc = cx_gt + (r+n)*np.cos(t)
    yc = cy_gt + (r+n)*np.sin(t)
    X_circ = np.c_[xc, yc]
    m, b = -1.0, 2.0
    x = np.linspace(-12, 12, N//2)
    y = m*x + b + 1.0*np.random.randn(N//2)
    X_line = np.c_[x, y]
    X = np.vstack([X_circ, X_line])

    (a,b,d), inl_line = ransac_line(X, thr=0.35, min_inliers=25, iters=1000)
    rem = np.delete(X, inl_line, axis=0)
    (cx,cy,r), inl_circ = ransac_circle(rem, thr=0.5, min_inliers=25, iters=2000)

    print("Line (a,b,d):", (a,b,d), " | line inliers:", len(inl_line))
    print("Circle (cx,cy,r):", (cx,cy,r), " | circle inliers:", len(inl_circ))

