import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

rng = np.random.default_rng(0)

N = 100
half_n = N // 2
r = 10.0
x0_gt, y0_gt = 2.0, 3.0
s_circ = r / 16.0
t = rng.uniform(0.0, 2.0*np.pi, half_n)
n = s_circ * rng.standard_normal(half_n)
xc = x0_gt + (r + n) * np.cos(t)
yc = y0_gt + (r + n) * np.sin(t)
X_circ = np.column_stack([xc, yc])

s_line = 1.0
m, b = -1.0, 2.0
x = np.linspace(-12.0, 12.0, half_n)
y = m * x + b + s_line * rng.standard_normal(half_n)
X_line = np.column_stack([x, y])

X = np.vstack([X_circ, X_line])

def fit_line_from_two_points(p, q):
    vx, vy = q[0]-p[0], q[1]-p[1]
    a, b = -vy, vx
    norm = np.hypot(a, b)
    if norm == 0: 
        return None
    a, b = a/norm, b/norm
    d = a*p[0] + b*p[1]
    return np.array([a, b, d])

def line_dist(params, pts):
    a, b, d = params
    return np.abs(a*pts[:,0] + b*pts[:,1] - d)

def refine_line(params_init, inliers):
    def obj(u):
        a, b, d = u
        nrm = np.hypot(a, b)
        if nrm == 0:
            return 1e9
        a, b = a/nrm, b/nrm
        return np.sum(line_dist([a,b,u[2]], inliers)**2)
    res = minimize(obj, params_init, method="Powell", options={"maxiter":500, "disp":False})
    a, b, d = res.x
    nrm = np.hypot(a, b)
    a, b = a/nrm, b/nrm
    return np.array([a, b, d])

def circle_from_three_points(p1, p2, p3):
    A = np.array([
        [2*(p2[0]-p1[0]), 2*(p2[1]-p1[1])],
        [2*(p3[0]-p1[0]), 2*(p3[1]-p1[1])]
    ])
    b = np.array([
        p2[0]**2 - p1[0]**2 + p2[1]**2 - p1[1]**2,
        p3[0]**2 - p1[0]**2 + p3[1]**2 - p1[1]**2
    ])
    if np.linalg.cond(A) > 1e12:
        return None
    c = np.linalg.solve(A, b)
    x0, y0 = c[0], c[1]
    r = np.hypot(p1[0]-x0, p1[1]-y0)
    return np.array([x0, y0, r])

def circle_residuals(params, pts):
    x0, y0, r = params
    return np.abs(np.hypot(pts[:,0]-x0, pts[:,1]-y0) - r)

def refine_circle(params_init, inliers):
    params_init = params_init.copy()
    params_init[2] = max(1e-3, params_init[2])
    def obj(u):
        x0, y0, r = u
        if r <= 0: 
            return 1e12
        return np.sum(circle_residuals(u, inliers)**2)
    res = minimize(obj, params_init, method="Powell", options={"maxiter":800, "disp":False})
    x0, y0, r = res.x
    r = max(r, 1e-6)
    return np.array([x0, y0, r])

def ransac_line(X, iters=300, thr=0.5, min_consensus=25):
    best = {"err": np.inf, "model": None, "mask": None, "sample": None}
    n = len(X)
    for _ in range(iters):
        i, j = rng.choice(n, size=2, replace=False)
        model = fit_line_from_two_points(X[i], X[j])
        if model is None:
            continue
        dists = line_dist(model, X)
        mask = dists <= thr
        if mask.sum() < min_consensus:
            continue
        err = dists[mask].mean()
        if err < best["err"]:
            best = {"err": err, "model": model, "mask": mask, "sample": (i, j)}
    if best["model"] is None:
        return best
    refined = refine_line(best["model"], X[best["mask"]])
    dists = line_dist(refined, X)
    mask = dists <= thr
    best.update({"model": refined, "mask": mask, "err": dists[mask].mean()})
    return best

def ransac_circle(X, iters=600, thr=0.6, min_consensus=25):
    best = {"err": np.inf, "model": None, "mask": None, "sample": None}
    n = len(X)
    for _ in range(iters):
        i, j, k = rng.choice(n, size=3, replace=False)
        model = circle_from_three_points(X[i], X[j], X[k])
        if model is None:
            continue
        res = circle_residuals(model, X)
        mask = res <= thr
        if mask.sum() < min_consensus:
            continue
        err = res[mask].mean()
        if err < best["err"]:
            best = {"err": err, "model": model, "mask": mask, "sample": (i, j, k)}
    if best["model"] is None:
        return best
    refined = refine_circle(best["model"], X[best["mask"]])
    res = circle_residuals(refined, X)
    mask = res <= thr
    best.update({"model": refined, "mask": mask, "err": res[mask].mean()})
    return best

line_res = ransac_line(X, iters=400, thr=0.6, min_consensus=25)
remnant = X[~line_res["mask"]] if line_res["mask"] is not None else X
circ_res = ransac_circle(remnant, iters=800, thr=0.8, min_consensus=25)

fig, ax = plt.subplots(1,1,figsize=(8,8))
ax.scatter(X[:,0], X[:,1], s=12, c="#666666", label="All points")

if line_res["sample"] is not None:
    p, q = X[list(line_res["sample"])]
    ax.scatter([p[0], q[0]],[p[1], q[1]], c="lime", s=60, marker="x", label="Best sample for line")
if line_res["mask"] is not None:
    ax.scatter(X[line_res["mask"],0], X[line_res["mask"],1], s=18, c="#1f77b4", label="Line inliers")
if line_res["model"] is not None:
    a,b,d = line_res["model"]
    xs = np.linspace(X[:,0].min()-2, X[:,0].max()+2, 400)
    ys = (d - a*xs)/b
    ax.plot(xs, ys, "b-", lw=2, label="RANSAC line")

if circ_res["sample"] is not None:
    ps = remnant[list(circ_res["sample"])]
    ax.scatter(ps[:,0], ps[:,1], c="orange", s=60, marker="x", label="Best sample for circle")
if circ_res["mask"] is not None:
    ax.scatter(remnant[circ_res["mask"],0], remnant[circ_res["mask"],1], s=18, c="#d62728", label="Circle inliers")
if circ_res["model"] is not None:
    x0,y0,rr = circ_res["model"]
    circ = plt.Circle((x0,y0), rr, edgecolor="#d62728", facecolor="none", lw=2, label="RANSAC circle")
    ax.add_patch(circ)

gt_circle = plt.Circle((x0_gt,y0_gt), r, edgecolor="g", facecolor="none", lw=2, label="Ground truth circle")
ax.add_patch(gt_circle)
xs = np.linspace(X[:,0].min()-2, X[:,0].max()+2, 400)
ax.plot(xs, m*xs + b, "m--", lw=2, label="Ground truth line")

ax.set_aspect("equal", adjustable="box")
ax.legend(loc="upper right", fontsize=9)
ax.set_title("RANSAC: line first, then circle")
plt.tight_layout()
plt.show()

print("Line model [a,b,d]:", line_res["model"])
print("Line inliers:", int(line_res["mask"].sum()) if line_res["mask"] is not None else 0, "  mean error:", float(line_res["err"]))
print("Circle model [x0,y0,r]:", circ_res["model"])
print("Circle inliers:", int(circ_res["mask"].sum()) if circ_res["mask"] is not None else 0, "  mean error:", float(circ_res["err"]))
